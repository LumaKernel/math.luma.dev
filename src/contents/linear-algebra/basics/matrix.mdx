<Config
  title="行列の定義"
  published
/>

## <Q w="mat" k />

<Q w="mat" />とは<Q w="elem" />を縦横に格子状に並べたもの、というのが素朴な定義。<Q w="elem" />、<Q w="mat" />とは一般にはなにか、という話が発展して議論されることになる。
それまでは、<Q w="elem" />は特に断りがなければ<Q w="real" />とする。一部、<Q w="comp" />とする場合もあるが、そのときは明記する。

## <Q w="mat" k />の表記

```math
\begin{matrix*}[l]
    A=
  &
    \begin{pmatrix}
      a_{0,0} & a_{0,1} & \cdots & a_{0,m-1}\\
      a_{1,0} & a_{1,1} & \cdots & a_{1,m-1}\\
      \vdots & \vdots & \ddots & \vdots\\
      a_{n-1,0} & a_{n-1,1} & \cdots & a_{n-1,m-1}\\
    \end{pmatrix}
  &
    \begin{matrix}
      \leftarrow\load{q:row}\\
      \\
      \\
      \\
    \end{matrix}
  \\
  &
    \kern{1.4em}\raisebox{0.6em}{$\uparrow$}
  &
  \\
  &
    \kern{0.2em}\load{q:column}
  &
\end{matrix*}
```

括弧は丸括弧$()$ではなく角括弧$[]$が使われることもある。上記のような行列を$n \times m$の <Q w="mat" /> と書く。

$n$は行数、$m$は列数と呼ぶ。

添字は基本的に$1$から始める事が多いと思うが、このサイトでは$0$で始めることにする。

$1 \times 1$の<Q w="mat" />$(a)$は単なる$a$と表記する。これは、基本的に$1 \times 1$の<Q w="mat" />と<Q w="scalar" />を<Q w="identify"/>しても、各種の性質が成立するからである。

$A = (a_{i, j})$とも書く。この表記は形式的な議論をする際に有用となる。また、$i, j$をデフォルトの<Q w="index"/>用の<Q w="variable"/>とし、$A=(a_{i, k})_{i, k}$などのように特別に明示することにする。つまり、$(a_{i, j})=(a_{i, j})_{i,j}=(a_{s,t})_{s,t}$とする。

今後は、$A=(a_{i,j})$,$B=(b_{i,j})$,$A^\prime=(a^\prime_{i,j})$などのアルファベットに対応するものを自然な定義として、特別の断りなしに用いる。

## <Q w="mat" k />の例

$2 \times 2$の<Q w="mat" />

```math
\begin{pmatrix}
1 & 2 \\
3 & 4 \\
\end{pmatrix}
```

$3 \times 2$の<Q w="mat" />

```math
\begin{pmatrix}
0.1 & 0 \\
0.2 & \pi \\
0.3 & 0 \\
\end{pmatrix}
```

## 余談: <Q w="mat" k d/>全体の<Q w="set" k d />

このサイトでは、<Q w="mat"/>全体の<Q w="set"/>を$\R^{n\times m}$と書くことにする。
根拠としては、<Q w="set-theory"/>では<Q w="nat"/>を$0\coloneqq\{\}, 1\coloneqq\{0\},\ 2\coloneqq\{0, 1\}, \cdots$というふうに<Q w="set-theory"/>の<Q w="language"/>に翻訳する技法があるのだが、これを利用していると考える。
まず、$Y^X$というのは$f: X\rightarrow Y$なる<Q w="mapping"/>$f$すべてを表す<Q w="set"/>として定義される。
これらの定義は<Q w="power-set"/>の表記法のひとつである$2^S\coloneqq \mathcal{P}(S)$における$2$を$\{0,1\}$とみなした場合の整合性も取れている。
つまり、$n \times m = \{0, 1, \cdots, n-1\} \times \{0, 1, \cdots, m-1\}$ということになり、<Q w="index"/>$(i, j) \in n \times m$から$\R$への<Q w="mapping"/>が<Q w="mat"/>ということだ。

なお、他にも$M_{n,m}(\R)$と書くような流儀もある。

こうすると、$0 \times 0$の<Q w="mat"/>も考えられる。これはつまり、何も入っていない<Q w="mat"/>のみがある、ということだ。$\R^{0 \times 0} = \{\emptyset\}$(何も写さない<Q w="mapping"/>のみを含む<Q w="set"/>)ということになる。

## <Q w="scalar" k d />

各<Q w="elem" />単体を、<Q w="mat" />と区別して<Q w="scalar" />と呼ぶ。
今後、<Q w="mat" />同士の<Q w="op" />や、<Q w="mat" />と<Q w="scalar" />の<Q w="op" />が定義されることになる。

## <Q w="vec" k d />

<Q w="vec" />は<Q w="scalar" />値の<Q w="fin-seq"/>である。以下のように表記する。

```math
\mathbf{v}=
\begin{pmatrix}
v_0 \\
v_1 \\
\vdots \\
v_{n-1} \\
\end{pmatrix}
```

$n$のことをサイズと呼ぶことにする。

$n \times 1$の<Q w="mat" />を<Q w="c-vec" d/>、$1 \times n$の<Q w="mat" />を<Q w="r-vec" d/>と呼ぶ。

<Q w="vec" d/>と<Q w="c-vec" d/>とを<Q w="identify"/>する。

また、$n \times m$の<Q w="mat" />をサイズ$n$の<Q w="vec"/>$m$個を用いて以下のようにも記述する。

```math
A=
\begin{pmatrix}
\mathbf{v}_0 &
\mathbf{v}_1 &
\cdots &
\mathbf{v}_{m-1} \\
\end{pmatrix}
```

### <Q w="vec" k />の例

```math
\mathbf{v}=
\begin{pmatrix}
1 \\
2 \\
3 \\
4 \\
\end{pmatrix}
```

```math
\mathbf{e}_2=
\begin{pmatrix}
0 \\ 0 \\ 1 \\ 0 \\
\end{pmatrix}
```

### <Q w="r-vec" k />の例

```math
\mathbf{e}^\prime_1=
\begin{pmatrix}
0 & 1 & 0 & 0 \\
\end{pmatrix}
```

## <Q w="row" />と<Q w="column" />の覚え方

<Q w="row" />と<Q w="column" />は以下のような暗記法がよく紹介される。

<Graph w="row-column" />

## <Q w="index" k />の順番の覚え方

<C w="row-column" template="覚え方%s. " start={1} />

$a_{i,j}$の$i$や$j$のことを<Q w="index" d />と呼ぶ。

### <C w="row-column"/>座標系の軸に対応させてYXと覚える

一般的な二次元のデカルト座標系の軸は、おそらく横方向に$x$,縦方向に$y$が取られることが多いと思われる。それを基準に、$y, x$の順にインデックスを指定する、と覚える。

### <C w="row-column"/>プログラムの二次元配列と対応させて覚える

後述の[プログラムにおける行列](#プログラムにおける行列)にある、二次元の<Q w="array" />に対応させ、そのインデックス指定順と同一であると考える。

## プログラムにおける<Q w="mat" />

プログラムにおいては、しばしば二次元の<Q w="array" />で表現される。

Python

```python
a = [[0 for j in range(3)] for i in range(3)]
print(a)
```

```json
[[0, 0, 0], [0, 0, 0], [0, 0, 0]]
```

Rust

```rust
fn main() {
    let a: Vec<Vec<i32>> = (0..3)
        .into_iter()
        .map(|_| (0..3).map(|_| 0).collect())
        .collect();
    println!("{:?}", a)
}
```


```json
[[0, 0, 0], [0, 0, 0], [0, 0, 0]]
```

## 余談: 一般化に備えて

前述の通り、<Q w="elem" />などの<Q w="algebraic-structure" />が何なのか、という話はのちに一般化される。基本的には<Q w="real" /> $\R$ や<Q w="comp" /> $\mathbb{C}$ として議論するが、すべて、<Q w="field" />としての性質のみを用いることに着目するとよい。つまり、<Q w="field" /> $K$に一般化されることになる。

以下に、<Q w="field" d/>の<Q w="axiom"/>を予備知識の必要ない簡単な形式で書く。

<Q w="set"/>$K$と二項<Q w="operator"/> (<Q w="add"/>)$\sdot + \sdot: K\times K \rightarrow K$,(<Q w="mult"/>)$\sdot \times \sdot: K\times K \rightarrow K$の<Q w="tuple"/>$(K, +, \times)$であって、

1. <Q w="add"/>の<Q w="identity"/>$0$の存在: $\exists ~ 0 ~ [0 + a = a + 0 = a]$
1. <Q w="add"/>の<Q w="inverse"/>の存在: $\exists ~ b \in K ~ [a + b = 0 \wedge b + a = 0]$
  このような$b$は他の<Q w="axiom"/>により一意に存在することがわかる。それを $-a$ と表記する。
1. <Q w="add"/>の<Q w="commutativity" />: $a + b = b + a$
1. <Q w="add"/>の<Q w="associativity" />: $a + (b + c) = (a + b) + c$
1. <Q w="mult"/>の<Q w="identity"/>$1$の存在: $\exists ~ 1 ~ [1 \times a = a \times 1 = a]$
1. <Q w="mult"/>の<Q w="inverse"/>の存在: $a \in (K\setminus\{0\})$について、$\exists ~ b \in K ~ [a \times b = 1 \wedge b \times a = 1]$
  このような$b$は他の<Q w="axiom"/>により一意に存在することがわかる。それを$a^{-1}$と表記する。
1. <Q w="mult"/>の<Q w="commutativity" />: $a \times b = b \times a$
1. <Q w="mult"/>の<Q w="associativity" />: $a \times (b \times c) = (a \times b) \times c$
1. <Q w="add"/>と<Q w="mult"/>の<Q w="distributivity" />: $a(b+c) = ab + ac$

なお、<Q w="mult"/>の<Q w="operator"/>は省略することがある。

これからの議論が上記の性質しか使っていないと確認できることが重要。
例えば、<Q w="real" />特有の性質は使わないということだ。さらに具体的には、例えば以下のようなことが守られるということ。

1. <Q w="rat"/>と<Q w="irrat"/>で場合分けするといったことをしない。
1. $2.2$などの$0, 1$以外の特殊な値を定義に使用しない。

<Q w="mat" />はさらにその後、<Q w="lin-sp"/>を対象として一般化される。そして、定義のいくつかの部分は<Q w="inf"/>へと拡張される。
