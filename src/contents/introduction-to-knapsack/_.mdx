```toml
title = "ナップサック問題の基礎"
published = true

[import]
Prob1Ex1 = "!"
Prob1Stmt = "!"
Prob1StmtTable = "!"
Prob1Illust1 = "!"
Prob1Illust2 = "!"
```

## 基本的なナップサック問題の概要

まずは直感的な説明から入る。

サイズ$S$のナップサックにいくつかの荷物を詰め込む。荷物は$N$個あり、それぞれ$0$から番号が振られている。荷物$i$はサイズ$x_i$、価値$v_i$である。詰め込む荷物のサイズが$S$を超えないようにしながら、価値の合計値を最大化するような荷物の選び方を求めたい。

<Prob1Stmt/>
<Prob1Ex1/>

ナップサック問題を定式化すると以下のようになる。

```math
\begin{matrix*}[l]
  \text{maximize}
    & \t{\mathbb{c}} \mathbb{v} \\
  \text{subject to}
    & c_i \in \{0, 1\} \\
    & \t{\mathbb{c}} \mathbb{x} \leq S \\
\end{matrix*}
```

- $c_i$: 荷物$i$を採用するかどうか。採用する場合は$c_i=1$にする。
- $\mathbb{c}, \mathbb{v}, \mathbb{x}$はベクトルで、$\t{\mathbb{c}} \mathbb{v} = \sum_{i=0}^{N-1} c_i v_i$を意味する。

## 最適解が求まらない方法

「単位サイズあたりの価値($v_i/x_i$)の大きい順から入れる」のような貪欲法が思いつくかもしれない。

しかし、こういったアプローチはナップサック問題では成功しない。
実際に、この貪欲法は上記に書いた例が反例となる。

## 愚直な方法

すべての荷物の入れ方を考える。これは時間計算量$\Omicron(N \cdot 2^N)$で求まる。

## ナップサック問題の小さい問題の作り方を考える

動的計画法は、問題をより小さな問題に帰着させて解く手法だ。
重要な出発点は「仮にこの荷物を入れたら最適解になるだろうか」と場合分けして考えることだ。仮に採用した場合、その荷物がなくなり、サイズが小さくなったナップサック問題が残ると考えられる。

もう少し網羅的に、問題のどのようなパラメーターが、より小さい部分問題が考えられそうかを見ていく。

- ナップサックのサイズ$S$
- 採用可能な荷物
  - 何番目の荷物までが採用可能か
  - 部分集合を考える
- 各荷物のパラメータ（サイズ、価値）
- 達成すべき合計価値の最低値

上記は、ナップサック問題に限らず、動的計画法を適用する準備として重要な観点となる。ひとつひとつ見ていく。

### サイズ

まずはわかりやすいサイズのようなものを小さくすることを考える。たとえば、$S=8$の問題なら、ナップサックがより小さくなった$S=7,6,5, \cdots$の場合を考えるということ。

### 採用可能な荷物

もとの問題のうち、一部の荷物しか与えられていない場合を考える。

ナップサック問題では、「何番目の荷物までが採用可能か」を考えるとうまくいくことが多い。こちらは、$\Omicron(N)$などの線形に近い時間計算量になる。

「部分集合を考える」方法は、ナップサック問題のバリアントや、巡回セールスマン問題で必要になる考え方だ。
この方法はbitDPと呼ばれることもある。$\Omicron(2^N)$や、半分全列挙（MITM）と組み合わせて$\Omicron(1.415^N)$などの指数時間計算量になる。

線形の方が良いのは当然だが、「何番目の荷物までが採用可能か」という方法は、ナップサック問題のような、採用の順序が影響しない問題でないと適用できない。

### 各荷物のパラメータ

$x_i$や$v_i$を変えるということ。これを変えて考えるということはまずない。どのように変えられるか、という組み合わせが荷物の数に対して指数的に増えてしまうため。

### 達成すべき合計価値の最低値

まず問題を「最大化」から「ある値以上にすることが達成可能かどうか」という決定問題に変換し、その目標値の要求を小さくするということである。
ナップサック問題でいえば、あらたな問題のパラメータ$V$を考えて、$\t{\mathbb{c}\mathbb{v}} \ge V$を満たすかどうか、という問題に変える。

## ナップサック問題をより小さな問題に帰着してみる

各荷物は採用するか、しないか、の2択だ。よって、各荷物についてこの問いを行う事ができれば、最適解が求まることになる。

ここで、まず荷物$6$から、ナップサックに入れるか入れないかの場合分けを考えてみる。

---

荷物$6$を入れる場合。この場合、荷物が一つ減り、ナップサックが$x_6=1$小さくなったナップサック問題を解くことで最適解が求まる。$v_6=1$はあとから足せば良い。

<Prob1Illust1/>

---

荷物$6$を入れない場合。この場合、単に荷物が一つ減ったナップサック問題を解くことで最適解が求まる。


<Prob1Illust2/>

---

上記の場合分けをすべての荷物に対して行うと、全く荷物がない状態に帰着される事がわかる。これは自明に価値の合計値の最大値が$0$であることがわかる。

より形式的に書けば、

```math
f(S, N) = \begin{cases}
  0 & (N=0) \\
  f(S, N-1) & (S<x_{N-1}) \\
  \max\{f(S, N-1), v_{N-1}+f(S-x_{N-1}, N-1)\} & (\text{otherwise}) \\
\end{cases}
```


このように、最終的に自明な問題へ帰着されるように問題を小さくしていく。これをPythonで書くと以下のようになる。

```python
def solve(*, S, N, x, v):
    """
    ナップサック問題を解き、達成可能な最大の価値合計値を返す。
    """
    # xとvは余計なコピーを避けるために、そのまま再帰呼び出しで渡している
    if N == 0:
        # 荷物が存在しないなら、自明に0
        return 0
    if S < x[N-1]:
        # 最後の荷物がそもそも入らないなら、存在しないのと同じ
        return solve(S=S, N=N-1, v=v, x=x)
    return max(
        # 最後の荷物を採用する場合
        v[N-1] + solve(S=S - x[N-1], N=N-1, v=v, x=x),
        # 最後の荷物を採用しない場合
        solve(S=S, N=N-1, v=v, x=x),
    )

# 実行例
print(solve(
    S=8,
    N=7,
    x=[3, 3, 7, 4, 2, 5, 1],
    v=[1, 3, 10, 6, 1, 6, 1],
))
```

ただし、これでは荷物の数$N$に対して指数的に呼び出しが行われてしまう。

問題は、同じ$S, N$に対して、答えが同一であるにも関わらず、毎回再帰呼び出しを行って求めてしまっているためだ。

これは、以下のようなメモ化を用いることで効率的に計算できる。

```python
def memoize(fn):
    """
    fnをキーワード引数SとNでメモ化する
    """
    memo = dict()
    def wrapped(*, S, N, **kwargs):
        if (S, N) not in memo:
            memo[(S, N)] = fn(S=S, N=N, **kwargs)
        return memo[(S, N)]
    return wrapped

# 実行例
print(memoize(solve)(
    S=8,
    N=7,
    x=[3, 3, 7, 4, 2, 5, 1],
    v=[1, 3, 10, 6, 1, 6, 1],
))
```

---

メモ化した方法はどれほど効率的だろうか。計算量を考える。

さて、サイズが$0, 1, \cdots, S$、「何番目の荷物まで採用可能か」を$0, \cdots, N$と変えた問題に帰着して考えた。
このとき、$(S+1) (N+1)$通り程度の小さい問題を考えているのだが、これを表にして見るとわかりやすい。

<Prob1StmtTable/>


この表が結局メモ化のメモに相当する。結局それぞれの値を求めるのに初回だけどれくらい時間がかかるかを考えると、たかだか2通りなので時間計算量、空間計算量ともに$\Omicron(SN)$となる。

---

上記の表を直接、2次元配列として求めることも可能だ。

```python
def solve_inline(*, S, N, x, v):
    """
    ナップサック問題を解き、達成可能な最大の価値合計値を返す。
    メモテーブルを直接求める。
    """
    table = [[0 for n in range(N + 1)] for s in range(S + 1)]
    for n in range(1, N + 1):
        for s in range(S + 1):
            if s < x[n-1]:
                # 荷物n-1がそもそも入らない場合
                table[s][n] = table[s][n-1]
            else:
                table[s][n] = max(
                    # 荷物n-1を採用しない場合
                    table[s][n-1],
                    # 荷物n-1を採用する場合
                    v[n-1] + table[s-x[n-1]][n-1],
                )
    return table[S][N]

print(solve_inline(
    S=8,
    N=7,
    x=[3, 3, 7, 4, 2, 5, 1],
    v=[1, 3, 10, 6, 1, 6, 1],
))
```

計算量は同様だが、再帰呼び出しを行っていない。この方法は、たとえばRMQを用いたり、必要な部分のみメモリに残すような工夫することでより最適化できる。
{/* 詳しくは[#応用問題]()と[#その他のバリアント]()も参照。 */}


## 応用問題

- 最大値とともに、解に対応する荷物の組み合わせを出力するように変更せよ。ただし、そのような例が複数ある場合は、どれを出力してもよい。
  - 応用: 時間計算量$\Omicron(SN)$を悪化しないように構成せよ。テーブルに集合を格納しておく方法では達成できない。
- 価値$v_i$は小数でも問題ないか考察せよ。
- メモ化をする再帰関数を使うのに対し、展開してfor文で書くメリットを答えよ。
  - 常に純粋なアルゴリズム的利点があるというわけではない。
  - 言語によってはOSの事情によるメリットもある。こちらは現実的には答えられたほうが良い。
- 空間計算量を$2S$程度(プラス定数程度)にするアルゴリズムを考察せよ。また、$S$程度にするアルゴリズムを考察せよ。

## その他のバリアント

このページで紹介したナップサック問題は、01ナップサック問題とよばれるものだ。その他にも以下のようなバリエーションが考えられる。

- 各荷物をいくつでも入れることが可能だとどうなるか
- 負のサイズや負の価値が許容される場合にはどうなるか
- 各荷物でそれぞれ個別の個数制限がある場合はどうなるか
- 01ナップサック問題において、パラメータがある程度ランダムな場合に、よりよい解法はないか

これらについては、[ナップサック問題 - cp.luma.dev](https://cp.luma.dev/dynamic-programming/knapsack)でアルゴリズムの実装と証明を書いている。
最後については[分枝限定法 - cp.luma.dev](https://cp.luma.dev/algorithm/branch-and-bound)で触れている。

